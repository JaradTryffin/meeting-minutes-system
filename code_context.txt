// File: components/Heading.tsx
interface HeadingProps {
  title: string;
  description: string;
}

export const Heading: React.FC<HeadingProps> = ({ title, description }) => {
  return (
    <div>
      <h2 className="text-3xl font-bold tracking-tight">{title}</h2>
      <p className="text-sm text-muted-foreground">{description}</p>
    </div>
  );
};

// File: components/data-table.tsx
"use client";

import { ColumnDef, getCoreRowModel } from "@tanstack/table-core";
import { flexRender, useReactTable } from "@tanstack/react-table";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";

interface DataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[];
  data: TData[];
}

export function DataTable<TData, TValue>({
  columns,
  data,
}: DataTableProps<TData, TValue>) {
  const table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
  });

  return (
    <div className="rounded-md border">
      <Table>
        <TableHeader>
          {table.getHeaderGroups().map((headerGroup) => (
            <TableRow key={headerGroup.id}>
              {headerGroup.headers.map((header) => {
                return (
                  <TableHead key={header.id}>
                    {header.isPlaceholder
                      ? null
                      : flexRender(
                          header.column.columnDef.header,
                          header.getContext(),
                        )}
                  </TableHead>
                );
              })}
            </TableRow>
          ))}
        </TableHeader>
        <TableBody>
          {table.getRowModel().rows?.length ? (
            table.getRowModel().rows.map((row) => (
              <TableRow
                key={row.id}
                data-state={row.getIsSelected() && "selected"}
              >
                {row.getVisibleCells().map((cell) => (
                  <TableCell key={cell.id}>
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </TableCell>
                ))}
              </TableRow>
            ))
          ) : (
            <TableRow>
              <TableCell colSpan={columns.length} className="h-24 text-center">
                No results.
              </TableCell>
            </TableRow>
          )}
        </TableBody>
      </Table>
    </div>
  );
}

// File: components/menu.tsx
import {
  Menubar,
  MenubarCheckboxItem,
  MenubarContent,
  MenubarItem,
  MenubarMenu,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSeparator,
  MenubarShortcut,
  MenubarSub,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarTrigger,
} from "@/components/ui/menubar";
import {
  NavigationMenu,
  NavigationMenuContent,
  NavigationMenuItem,
  NavigationMenuLink,
  NavigationMenuList,
  NavigationMenuTrigger,
} from "@/components/ui/navigation-menu";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";

export function Menu() {
  return (
    <Menubar className="rounded-none px-2 lg:px-4 p-7">
      <div className="flex w-full justify-evenly">
        <h2 className="tracking-tighter font-extrabold text-2xl">
          Meeting Minutes System
        </h2>

        <div className="flex">
          <MenubarMenu>
            <MenubarTrigger>Members</MenubarTrigger>
            <MenubarContent>
              <MenubarItem>
                New Tab <MenubarShortcut>⌘T</MenubarShortcut>
              </MenubarItem>
              <MenubarItem>
                New Window <MenubarShortcut>⌘N</MenubarShortcut>
              </MenubarItem>
              <MenubarItem disabled>New Incognito Window</MenubarItem>
              <MenubarSeparator />
              <MenubarSub>
                <MenubarSubTrigger>Share</MenubarSubTrigger>
                <MenubarSubContent>
                  <MenubarItem>Email link</MenubarItem>
                  <MenubarItem>Messages</MenubarItem>
                  <MenubarItem>Notes</MenubarItem>
                </MenubarSubContent>
              </MenubarSub>
              <MenubarSeparator />
              <MenubarItem>
                Print... <MenubarShortcut>⌘P</MenubarShortcut>
              </MenubarItem>
            </MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Meeting</MenubarTrigger>
            <MenubarContent>
              <MenubarItem>
                Undo <MenubarShortcut>⌘Z</MenubarShortcut>
              </MenubarItem>
              <MenubarItem>
                Redo <MenubarShortcut>⇧⌘Z</MenubarShortcut>
              </MenubarItem>
              <MenubarSeparator />
              <MenubarSub>
                <MenubarSubTrigger>Find</MenubarSubTrigger>
                <MenubarSubContent>
                  <MenubarItem>Search the web</MenubarItem>
                  <MenubarSeparator />
                  <MenubarItem>Find...</MenubarItem>
                  <MenubarItem>Find Next</MenubarItem>
                  <MenubarItem>Find Previous</MenubarItem>
                </MenubarSubContent>
              </MenubarSub>
              <MenubarSeparator />
              <MenubarItem>Cut</MenubarItem>
              <MenubarItem>Copy</MenubarItem>
              <MenubarItem>Paste</MenubarItem>
            </MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Meeting Items</MenubarTrigger>
            <MenubarContent>
              <MenubarCheckboxItem>
                Always Show Bookmarks Bar
              </MenubarCheckboxItem>
              <MenubarCheckboxItem checked>
                Always Show Full URLs
              </MenubarCheckboxItem>
              <MenubarSeparator />
              <MenubarItem inset>
                Reload <MenubarShortcut>⌘R</MenubarShortcut>
              </MenubarItem>
              <MenubarItem disabled inset>
                Force Reload <MenubarShortcut>⇧⌘R</MenubarShortcut>
              </MenubarItem>
              <MenubarSeparator />
              <MenubarItem inset>Toggle Fullscreen</MenubarItem>
              <MenubarSeparator />
              <MenubarItem inset>Hide Sidebar</MenubarItem>
            </MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Reports</MenubarTrigger>
            <MenubarContent>
              <MenubarRadioGroup value="benoit">
                <MenubarRadioItem value="andy">Andy</MenubarRadioItem>
                <MenubarRadioItem value="benoit">Benoit</MenubarRadioItem>
                <MenubarRadioItem value="Luis">Luis</MenubarRadioItem>
              </MenubarRadioGroup>
              <MenubarSeparator />
              <MenubarItem inset>Edit...</MenubarItem>
              <MenubarSeparator />
              <MenubarItem inset>Add Profile...</MenubarItem>
            </MenubarContent>
          </MenubarMenu>
        </div>

        <Avatar>
          <AvatarFallback>JT</AvatarFallback>
        </Avatar>
      </div>
    </Menubar>
  );
}

// File: components/sidebar.tsx
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { User } from "lucide-react";

export function Sidebar() {
  return (
    <div className={cn("pb-12 h-full")}>
      <div className="space-y-4 py-4">
        <div className="px-3 py-2">
          <h2 className="mb-2 px-4 text-lg font-semibold tracking-tight">
            Members
          </h2>
          <div className="space-y-1">
            <Button variant="secondary" className="w-full justify-start">
              <User />
              Add Member
            </Button>
          </div>
        </div>


      </div>
    </div>
  );
}

// File: components/ui/avatar.tsx
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

// File: components/ui/button.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

// File: components/ui/menubar.tsx
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const MenubarMenu = MenubarPrimitive.Menu

const MenubarGroup = MenubarPrimitive.Group

const MenubarPortal = MenubarPrimitive.Portal

const MenubarSub = MenubarPrimitive.Sub

const MenubarRadioGroup = MenubarPrimitive.RadioGroup

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}

// File: components/ui/navigation-menu.tsx
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}

// File: components/ui/separator.tsx
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

// File: components/ui/table.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

// File: app/api/meeting/[id]/items/route.ts
import prisma from "@/lib/prisma";
import { NextResponse } from "next/server";

export async function GET(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const meetingItems = await prisma.meetingItemStatus.findMany({
      where: { meetingId: params.id },
      include: {
        meetingItem: true,
        responsiblePerson: true,
      },
    });

    return NextResponse.json(meetingItems);
  } catch (error) {
    console.error(
      `[GET_MEETING_ITEMS_${params.id}]- Failed to fetch meeting items:`,
      error,
    );
    return NextResponse.json(
      { error: "Failed to fetch meeting items" },
      { status: 500 },
    );
  }
}

// File: app/api/meeting/[id]/next/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";

export async function GET(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const nextMeeting = await prisma.meeting.findFirst({
      where: { previousMeetingId: params.id },
    });

    if (!nextMeeting) {
      return NextResponse.json(
        { error: "No next meeting found" },
        { status: 404 },
      );
    }

    return NextResponse.json(nextMeeting);
  } catch (error) {
    console.error(
      `[GET_MEETING_NEXT_${params.id}] - Failed to fetch next meeting:`,
      error,
    );
    return NextResponse.json(
      { error: "Failed to fetch next meeting" },
      { status: 500 },
    );
  }
}

// File: app/api/meeting/[id]/previous/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";

export async function GET(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const currentMeeting = await prisma.meeting.findUnique({
      where: { id: params.id },
      include: { previousMeeting: true },
    });

    if (!currentMeeting) {
      return NextResponse.json({ error: "Meeting not found" }, { status: 404 });
    }

    if (!currentMeeting.previousMeeting) {
      return NextResponse.json(
        { error: "No previous meeting found" },
        { status: 404 },
      );
    }

    return NextResponse.json(currentMeeting.previousMeeting);
  } catch (error) {
    console.error(
      `[GET_MEETING_PREVIOUS_${params.id}]-Failed to fetch previous meeting:`,
      error,
    );
    return NextResponse.json(
      { error: "Failed to fetch previous meeting" },
      { status: 500 },
    );
  }
}

// File: app/api/meeting/[id]/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";

export async function GET(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const meeting = await prisma.meeting.findUnique({
      where: {
        id: params.id,
      },
      include: {
        meetingType: true,
        itemStatuses: true,
      },
    });

    if (!meeting) {
      return NextResponse.json({ error: "Meeting not found" }, { status: 404 });
    }

    return NextResponse.json(meeting);
  } catch (error) {
    console.log(
      `[GET_MEETING_${params.id}] - Failed to fetch meeting : `,
      error,
    );
    return NextResponse.json(
      { error: "Failed to fetch meeting" },
      { status: 500 },
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const body = await request.json();
    const { meetingNumber, date, meetingTypeId, previousMeetingId, minutes } =
      body;

    const updatedMeeting = await prisma.meeting.update({
      where: { id: params.id },
      data: {
        meetingNumber,
        date: date ? new Date(date) : undefined,
        meetingTypeId,
        previousMeetingId,
        minutes,
      },
      include: { meetingType: true },
    });

    return NextResponse.json(updatedMeeting);
  } catch (error) {
    console.log(
      `[PUT_MEETING_${params.id}] - Failed to update meeting : `,
      error,
    );
    return NextResponse.json(
      { error: "Failed to update meeting" },
      { status: 500 },
    );
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    await prisma.meeting.delete({
      where: { id: params.id },
    });

    return NextResponse.json({ message: "Meeting deleted successfully" });
  } catch (error) {
    console.log(
      `[DELETE_MEETING_${params.id}] - Failed to delete meeting : `,
      error,
    );
    return NextResponse.json(
      { error: "Failed to delete meeting" },
      { status: 500 },
    );
  }
}

// File: app/api/meeting/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";

export async function GET(request: Request) {
  try {
    const meetings = await prisma.meeting.findMany({
      include: { meetingType: true },
    });
    return NextResponse.json(meetings);
  } catch (error) {
    console.error("[GET_MEETING] - Failed to fetch meetings", error);
    return NextResponse.json(
      { error: "Failed to fetch meeting" },
      { status: 500 },
    );
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { meetingNumber, date, meetingTypeId, previousMeetingId, minutes } =
      body;

    if (!meetingNumber || !date || !meetingTypeId) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 },
      );
    }

    const newMeeting = await prisma.meeting.create({
      data: {
        meetingNumber,
        date: new Date(date),
        meetingTypeId,
        previousMeetingId,
        minutes,
      },
      include: { meetingType: true },
    });
    return NextResponse.json(newMeeting, { status: 201 });
  } catch (error) {
    console.error("[POST_MEETING] - Failed to fetch meetings", error);
    return NextResponse.json(
      { error: "Failed to create meeting" },
      { status: 500 },
    );
  }
}

// File: app/api/meeting-item-statuses/[id]/route.ts
import prisma from "@/lib/prisma";
import { NextResponse } from "next/server";

export async function GET(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const meetingItemStatus = await prisma.meetingItemStatus.findUnique({
      where: { id: params.id },
      include: {
        meeting: true,
        meetingItem: true,
        responsiblePerson: true,
      },
    });

    if (!meetingItemStatus) {
      return NextResponse.json(
        { error: "Meeting item status not found" },
        { status: 404 },
      );
    }

    return NextResponse.json(meetingItemStatus);
  } catch (error) {
    console.error(
      `[GET_MEETING_ITEM_STATUSES_${params.id}] - Failed to fetch meeting item status:`,
      error,
    );
    return NextResponse.json(
      { error: "Failed to fetch meeting item status" },
      { status: 500 },
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const body = await request.json();
    const { status, actionRequired, responsiblePersonId } = body;

    const updatedMeetingItemStatus = await prisma.meetingItemStatus.update({
      where: { id: params.id },
      data: {
        status,
        actionRequired,
        responsiblePersonId,
      },
      include: {
        meeting: true,
        meetingItem: true,
        responsiblePerson: true,
      },
    });

    return NextResponse.json(updatedMeetingItemStatus);
  } catch (error) {
    console.error("Failed to update meeting item status:", error);
    return NextResponse.json(
      { error: "Failed to update meeting item status" },
      { status: 500 },
    );
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    await prisma.meetingItemStatus.delete({
      where: { id: params.id },
    });

    return NextResponse.json({
      message: "Meeting item status deleted successfully",
    });
  } catch (error) {
    console.error(
      `[DELETE_MEETING_ITEM_STATUSES_${params.id}] - Failed to delete meeting item status:`,
      error,
    );
    return NextResponse.json(
      { error: "Failed to delete meeting item status" },
      { status: 500 },
    );
  }
}

// File: app/api/meeting-item-statuses/route.ts
import prisma from "@/lib/prisma";
import { NextResponse } from "next/server";

export async function GET(request: Request) {
  try {
    const meetingItemStatuses = await prisma.meetingItemStatus.findMany({
      include: {
        meeting: true,
        meetingItem: true,
        responsiblePerson: true,
      },
    });
    return NextResponse.json(meetingItemStatuses);
  } catch (error) {
    console.error(
      "[GET_MEETING_ITEM-STATUSES]- Failed to fetch meeting item statuses:",
      error,
    );
    return NextResponse.json(
      { error: "Failed to fetch meeting item statuses" },
      { status: 500 },
    );
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const {
      status,
      actionRequired,
      meetingId,
      meetingItemId,
      responsiblePersonId,
    } = body;

    if (!status || !meetingId || !meetingItemId || !responsiblePersonId) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 },
      );
    }

    const newMeetingItemStatus = await prisma.meetingItemStatus.create({
      data: {
        status,
        actionRequired,
        meetingId,
        meetingItemId,
        responsiblePersonId,
      },
      include: {
        meeting: true,
        meetingItem: true,
        responsiblePerson: true,
      },
    });

    return NextResponse.json(newMeetingItemStatus, { status: 201 });
  } catch (error) {
    console.error(
      "[POST_MEETING_ITEM_STATUSES] - Failed to create meeting item status:",
      error,
    );
    return NextResponse.json(
      { error: "Failed to create meeting item status" },
      { status: 500 },
    );
  }
}

// File: app/api/meeting-items/[id]/history/route.ts
import prisma from "@/lib/prisma";
import { NextResponse } from "next/server";

export async function GET(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const meetingItemHistory = await prisma.meetingItemStatus.findMany({
      where: { meetingItemId: params.id },
      include: {
        meeting: true,
        responsiblePerson: true,
      },
      orderBy: { meeting: { date: "asc" } },
    });

    if (meetingItemHistory.length === 0) {
      return NextResponse.json(
        { error: "No history found for this meeting item" },
        { status: 404 },
      );
    }

    return NextResponse.json(meetingItemHistory);
  } catch (error) {
    console.error(
      `[GET_MEETING_ITEMS_${params.id}_HISTORY]- Failed to fetch meeting item history:`,
      error,
    );
    return NextResponse.json(
      { error: "Failed to fetch meeting item history" },
      { status: 500 },
    );
  }
}

// File: app/api/meeting-items/[id]/route.ts
import prisma from "@/lib/prisma";
import { NextResponse } from "next/server";

export async function GET(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const meetingItem = await prisma.meetingItem.findUnique({
      where: { id: params.id },
      include: {
        statuses: { include: { meeting: true, responsiblePerson: true } },
      },
    });

    if (!meetingItem) {
      return NextResponse.json(
        { error: "Meeting item not found" },
        { status: 404 },
      );
    }

    return NextResponse.json(meetingItem);
  } catch (error) {
    console.error(
      `[GET_MEETING_ITEMS_${params.id}]- Failed to fetch meeting item:`,
      error,
    );
    return NextResponse.json(
      { error: "Failed to fetch meeting item" },
      { status: 500 },
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const body = await request.json();
    const { description, dueDate, completedDate } = body;

    const updatedMeetingItem = await prisma.meetingItem.update({
      where: { id: params.id },
      data: {
        description,
        dueDate: dueDate ? new Date(dueDate) : undefined,
        completedDate: completedDate ? new Date(completedDate) : undefined,
      },
      include: {
        statuses: { include: { meeting: true, responsiblePerson: true } },
      },
    });

    return NextResponse.json(updatedMeetingItem);
  } catch (error) {
    console.error(
      `[PUT_MEETING_ITEMS_${params.id}]- Failed to update meeting item:`,
      error,
    );
    return NextResponse.json(
      { error: "Failed to update meeting item" },
      { status: 500 },
    );
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    await prisma.meetingItem.delete({
      where: { id: params.id },
    });

    return NextResponse.json({ message: "Meeting item deleted successfully" });
  } catch (error) {
    console.error(
      `[DELETE_MEETING_ITEMS_${params.id}]- Failed to delete meeting item:`,
      error,
    );
    return NextResponse.json(
      { error: "Failed to delete meeting item" },
      { status: 500 },
    );
  }
}

// File: app/api/meeting-items/route.ts
import prisma from "@/lib/prisma";
import { NextResponse } from "next/server";

export async function GET(request: Request) {
  try {
    const meetingItems = await prisma.meetingItem.findMany({
      include: {
        statuses: { include: { meeting: true, responsiblePerson: true } },
      },
    });
    return NextResponse.json(meetingItems);
  } catch (error) {
    console.error(`[GET_MEETING_ITEMS]- Failed to fetch meeting items:`, error);
    return NextResponse.json(
      { error: "Failed to fetch meeting items" },
      { status: 500 },
    );
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const {
      description,
      dueDate,
      meetingId,
      status,
      actionRequired,
      responsiblePersonId,
    } = body;

    if (!description || !meetingId || !status || !responsiblePersonId) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 },
      );
    }

    const newMeetingItem = await prisma.meetingItem.create({
      data: {
        description,
        dueDate: dueDate ? new Date(dueDate) : undefined,
        statuses: {
          create: {
            status,
            actionRequired,
            meetingId,
            responsiblePersonId,
          },
        },
      },
      include: {
        statuses: { include: { meeting: true, responsiblePerson: true } },
      },
    });

    return NextResponse.json(newMeetingItem, { status: 201 });
  } catch (error) {
    console.error(
      "[POST_MEETING_ITEMS] - Failed to create meeting item:",
      error,
    );
    return NextResponse.json(
      { error: "Failed to create meeting item" },
      { status: 500 },
    );
  }
}

// File: app/api/meeting-types/[id]/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";

export async function GET(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const meetingType = await prisma.meetingType.findUnique({
      where: {
        id: params.id,
      },
    });

    if (!meetingType) {
      return NextResponse.json(
        { error: "Meeting type not found" },
        { status: 404 },
      );
    }
    return NextResponse.json(meetingType);
  } catch (error) {
    console.log(
      `[GET_MEETING_TYPE_[${params.id}]] - Failed to fetch meeting type: `,
      error,
    );
    return NextResponse.json(
      { error: "Failed to fetch meeting type" },
      { status: 500 },
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const body = await request.json();
    const { name } = body;

    if (!name) {
      return NextResponse.json({ error: "Name is required" }, { status: 400 });
    }

    const updatedMeetingType = await prisma.meetingType.update({
      where: { id: params.id },
      data: { name },
    });

    return NextResponse.json(updatedMeetingType);
  } catch (error) {
    console.log(
      `[PUT_MEETING_TYPE_[${params.id}]] - Failed to update meeting type: `,
      error,
    );
    return NextResponse.json(
      { error: "Failed to update meeting type" },
      { status: 500 },
    );
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    await prisma.meetingType.delete({
      where: { id: params.id },
    });

    return NextResponse.json({ message: "Meeting type deleted successful" });
  } catch (error) {
    console.log(
      `[DELETE_MEETING_TYPE_[${params.id}]] - Failed to delete meeting type: `,
      error,
    );
    return NextResponse.json(
      { error: "Failed to delete meeting type" },
      { status: 500 },
    );
  }
}

// File: app/api/meeting-types/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";

export async function GET(request: Request) {
  try {
    const meetingTypes = await prisma.meetingType.findMany();
    return NextResponse.json(meetingTypes);
  } catch (error) {
    console.error("[GET_MEETING_TYPE] - Failed to fetch meeting types:", error);
    return NextResponse.json(
      { error: "Failed to fetch meeting types" },
      { status: 500 },
    );
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { name } = body;

    if (!name) {
      return NextResponse.json({ error: "Name is required" }, { status: 400 });
    }

    const newMeetingType = await prisma.meetingType.create({
      data: {
        name: name,
      },
    });

    return NextResponse.json(newMeetingType, { status: 201 });
  } catch (error) {
    console.error(
      "[POST_MEETING_TYPE] - Failed to create meeting type:",
      error,
    );
    return NextResponse.json(
      { error: "Failed to create meeting type" },
      { status: 500 },
    );
  }
}

// File: app/api/persons/[id]/items/route.ts
import prisma from "@/lib/prisma";
import { NextResponse } from "next/server";

export async function GET(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const personItems = await prisma.meetingItemStatus.findMany({
      where: { responsiblePersonId: params.id },
      include: {
        meetingItem: true,
        meeting: true,
      },
      orderBy: { meeting: { date: "desc" } },
    });

    if (personItems.length === 0) {
      return NextResponse.json(
        { message: "No items found for this person" },
        { status: 404 },
      );
    }

    return NextResponse.json(personItems);
  } catch (error) {
    console.error(
      `[GET_PERSON_${params.id}_ITEMS] - Failed to fetch person items:`,
      error,
    );
    return NextResponse.json(
      { error: "Failed to fetch person items" },
      { status: 500 },
    );
  }
}

// File: app/api/persons/[id]/route.ts
import prisma from "@/lib/prisma";
import { NextResponse } from "next/server";

export async function GET(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const person = await prisma.person.findUnique({
      where: { id: params.id },
    });

    if (!person) {
      return NextResponse.json({ error: "Person not found" }, { status: 404 });
    }

    return NextResponse.json(person);
  } catch (error) {
    console.error(
      `[GET_PERSONS_${params.id}] - Failed to fetch person:`,
      error,
    );
    return NextResponse.json(
      { error: "Failed to fetch person" },
      { status: 500 },
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const body = await request.json();
    const { name, email } = body;

    const updatedPerson = await prisma.person.update({
      where: { id: params.id },
      data: { name, email },
    });

    return NextResponse.json(updatedPerson);
  } catch (error) {
    console.error(
      `[PUT_PERSONS_${params.id}]- Failed to update person:`,
      error,
    );
    return NextResponse.json(
      { error: "Failed to update person" },
      { status: 500 },
    );
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    await prisma.person.delete({
      where: { id: params.id },
    });

    return NextResponse.json({ message: "Person deleted successfully" });
  } catch (error) {
    console.error(
      `[GET_PERSONS_${params.id}] - Failed to delete person:`,
      error,
    );
    return NextResponse.json(
      { error: "Failed to delete person" },
      { status: 500 },
    );
  }
}

// File: app/api/persons/route.ts
import prisma from "@/lib/prisma";
import { NextResponse } from "next/server";

export async function GET(request: Request) {
  try {
    const persons = await prisma.person.findMany();
    return NextResponse.json(persons);
  } catch (error) {
    console.error("[GET_PERSONS] - Failed to fetch persons:", error);
    return NextResponse.json(
      { error: "Failed to fetch persons" },
      { status: 500 },
    );
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { name, email } = body;

    if (!name || !email) {
      return NextResponse.json(
        { error: "Name and email are required" },
        { status: 400 },
      );
    }

    const newPerson = await prisma.person.create({
      data: { name, email },
    });

    return NextResponse.json(newPerson, { status: 201 });
  } catch (error) {
    console.error("[POST_PERSONS] - Failed to create person:", error);
    return NextResponse.json(
      { error: "Failed to create person" },
      { status: 500 },
    );
  }
}

// File: app/api/reports/items-by-meeting/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const meetingId = searchParams.get("meetingId");

    if (!meetingId) {
      return NextResponse.json(
        { error: "Meeting ID is required" },
        { status: 400 },
      );
    }

    const itemsByMeeting = await prisma.meetingItemStatus.findMany({
      where: { meetingId: meetingId },
      include: {
        meetingItem: true,
        responsiblePerson: true,
      },
      orderBy: { meetingItem: { description: "asc" } },
    });

    if (itemsByMeeting.length === 0) {
      return NextResponse.json(
        { message: "No items found for this meeting" },
        { status: 404 },
      );
    }

    return NextResponse.json(itemsByMeeting);
  } catch (error) {
    console.error("Failed to generate items by meeting report:", error);
    return NextResponse.json(
      { error: "Failed to generate items by meeting report" },
      { status: 500 },
    );
  }
}

// File: app/api/reports/items-by-meeting-type/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const meetingTypeId = searchParams.get("meetingTypeId");

    if (!meetingTypeId) {
      return NextResponse.json(
        { error: "Meeting Type ID is required" },
        { status: 400 },
      );
    }

    const itemsByMeetingType = await prisma.meetingItemStatus.findMany({
      where: {
        meeting: { meetingTypeId: meetingTypeId },
      },
      include: {
        meetingItem: true,
        meeting: true,
        responsiblePerson: true,
      },
      orderBy: [
        { meeting: { date: "desc" } },
        { meetingItem: { description: "asc" } },
      ],
    });

    if (itemsByMeetingType.length === 0) {
      return NextResponse.json(
        { message: "No items found for this meeting type" },
        { status: 404 },
      );
    }

    return NextResponse.json(itemsByMeetingType);
  } catch (error) {
    console.error("Failed to generate items by meeting type report:", error);
    return NextResponse.json(
      { error: "Failed to generate items by meeting type report" },
      { status: 500 },
    );
  }
}

// File: app/api/reports/items-by-person/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const personId = searchParams.get("personId");

    if (!personId) {
      return NextResponse.json(
        { error: "Person ID is required" },
        { status: 400 },
      );
    }

    const itemsByPerson = await prisma.meetingItemStatus.findMany({
      where: {
        responsiblePersonId: personId,
        meetingItem: {
          completedDate: null, // Only include incomplete items
        },
      },
      include: {
        meetingItem: true,
        meeting: true,
      },
      orderBy: { meetingItem: { dueDate: "asc" } },
    });

    if (itemsByPerson.length === 0) {
      return NextResponse.json(
        { message: "No items found for this person" },
        { status: 404 },
      );
    }

    return NextResponse.json(itemsByPerson);
  } catch (error) {
    console.error("Failed to generate items by person report:", error);
    return NextResponse.json(
      { error: "Failed to generate items by person report" },
      { status: 500 },
    );
  }
}

// File: app/api/reports/progress/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const itemId = searchParams.get("itemId");

    if (!itemId) {
      return NextResponse.json(
        { error: "Item ID is required" },
        { status: 400 },
      );
    }

    const progressReport = await prisma.meetingItemStatus.findMany({
      where: { meetingItemId: itemId },
      include: {
        meeting: true,
        responsiblePerson: true,
      },
      orderBy: { meeting: { date: "asc" } },
    });

    if (progressReport.length === 0) {
      return NextResponse.json(
        { error: "No progress found for this item" },
        { status: 404 },
      );
    }

    return NextResponse.json(progressReport);
  } catch (error) {
    console.error("Failed to generate progress report:", error);
    return NextResponse.json(
      { error: "Failed to generate progress report" },
      { status: 500 },
    );
  }
}

// File: app/api/reports/status-summary/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");

    if (!startDate || !endDate) {
      return NextResponse.json(
        { error: "Start date and end date are required" },
        { status: 400 },
      );
    }

    const statusSummary = await prisma.meetingItemStatus.groupBy({
      by: ["status"],
      where: {
        meeting: {
          date: {
            gte: new Date(startDate),
            lte: new Date(endDate),
          },
        },
      },
      _count: {
        status: true,
      },
    });

    if (statusSummary.length === 0) {
      return NextResponse.json(
        { message: "No status data found for the given period" },
        { status: 404 },
      );
    }

    return NextResponse.json(statusSummary);
  } catch (error) {
    console.error("Failed to generate status summary report:", error);
    return NextResponse.json(
      { error: "Failed to generate status summary report" },
      { status: 500 },
    );
  }
}

// File: app/api/status-types/[id]/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";

export async function GET(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const statusType = await prisma.statusType.findUnique({
      where: { id: params.id },
    });

    if (!statusType) {
      return NextResponse.json(
        { error: "Status type not found" },
        { status: 404 },
      );
    }

    return NextResponse.json(statusType);
  } catch (error) {
    console.error(
      `[GET_STATUS_TYPES_${params.id}]- Failed to fetch status type:`,
      error,
    );
    return NextResponse.json(
      { error: "Failed to fetch status type" },
      { status: 500 },
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const body = await request.json();
    const { name } = body;

    if (!name) {
      return NextResponse.json({ error: "Name is required" }, { status: 400 });
    }

    const updatedStatusType = await prisma.statusType.update({
      where: { id: params.id },
      data: { name },
    });

    return NextResponse.json(updatedStatusType);
  } catch (error) {
    console.error(
      `[PUT_STATUS_TYPES_${params.id}] - Failed to update status type:`,
      error,
    );
    return NextResponse.json(
      { error: "Failed to update status type" },
      { status: 500 },
    );
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    await prisma.statusType.delete({
      where: { id: params.id },
    });

    return NextResponse.json({ message: "Status type deleted successfully" });
  } catch (error) {
    console.error("Failed to delete status type:", error);
    return NextResponse.json(
      {
        error: `[DELETE_STATUS_TYPES_${params.id}]- Failed to delete status type`,
      },
      { status: 500 },
    );
  }
}

// File: app/api/status-types/route.ts
import prisma from "@/lib/prisma";
import { NextResponse } from "next/server";

export async function GET(request: Request) {
  try {
    const statusTypes = await prisma.statusType.findMany();
    return NextResponse.json(statusTypes);
  } catch (error) {
    console.error("[GET_STATUS_TYPES]- Failed to fetch status types:", error);
    return NextResponse.json(
      { error: "Failed to fetch status types" },
      { status: 500 },
    );
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { name } = body;

    if (!name) {
      return NextResponse.json({ error: "Name is required" }, { status: 400 });
    }

    const newStatusType = await prisma.statusType.create({
      data: { name },
    });

    return NextResponse.json(newStatusType, { status: 201 });
  } catch (error) {
    console.error("[POST_STATUS_STATUS]- Failed to create status type:", error);
    return NextResponse.json(
      { error: "Failed to create status type" },
      { status: 500 },
    );
  }
}

// File: app/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
// File: app/layout.tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { Menu } from "@/components/menu";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <Menu />
        {children}
      </body>
    </html>
  );
}

// File: app/page.tsx
import { Heading } from "@/components/Heading";
import axios from "axios";
import { DataTable } from "@/components/data-table";
import { memberColumns } from "@/util/members/columns";
import { Person } from "@prisma/client";
import prisma from "@/lib/prisma";

export default async function Home() {
  const members = await prisma.person.findMany();

  return (
    <div className="m-5">
      <div className="mb-5">
        <Heading title="Members" description="Manage members" />
      </div>

      <DataTable columns={memberColumns} data={members} />
    </div>
  );
}

